{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/meikaprince/Desktop/purrrfectPals/purrrfectpals/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst _require = require('url'),\n      URL = _require.URL;\n\nconst is = require('@sindresorhus/is');\n\nconst knownHookEvents = require('./known-hook-events');\n\nconst merge = (target, ...sources) => {\n  for (const source of sources) {\n    for (const _ref of Object.entries(source)) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      const key = _ref2[0];\n      const sourceValue = _ref2[1];\n\n      if (is.undefined(sourceValue)) {\n        continue;\n      }\n\n      const targetValue = target[key];\n\n      if (is.urlInstance(targetValue) && (is.urlInstance(sourceValue) || is.string(sourceValue))) {\n        target[key] = new URL(sourceValue, targetValue);\n      } else if (is.plainObject(sourceValue)) {\n        if (is.plainObject(targetValue)) {\n          target[key] = merge({}, targetValue, sourceValue);\n        } else {\n          target[key] = merge({}, sourceValue);\n        }\n      } else if (is.array(sourceValue)) {\n        target[key] = merge([], sourceValue);\n      } else {\n        target[key] = sourceValue;\n      }\n    }\n  }\n\n  return target;\n};\n\nconst mergeOptions = (...sources) => {\n  sources = sources.map(source => source || {});\n  const merged = merge({}, ...sources);\n  const hooks = {};\n\n  for (const hook of knownHookEvents) {\n    hooks[hook] = [];\n  }\n\n  for (const source of sources) {\n    if (source.hooks) {\n      for (const hook of knownHookEvents) {\n        hooks[hook] = hooks[hook].concat(source.hooks[hook]);\n      }\n    }\n  }\n\n  merged.hooks = hooks;\n  return merged;\n};\n\nconst mergeInstances = (instances, methods) => {\n  const handlers = instances.map(instance => instance.defaults.handler);\n  const size = instances.length - 1;\n  return {\n    methods,\n    options: mergeOptions(...instances.map(instance => instance.defaults.options)),\n    handler: (options, next) => {\n      let iteration = -1;\n\n      const iterate = options => handlers[++iteration](options, iteration === size ? next : iterate);\n\n      return iterate(options);\n    }\n  };\n};\n\nmodule.exports = merge;\nmodule.exports.options = mergeOptions;\nmodule.exports.instances = mergeInstances;","map":{"version":3,"sources":["/Users/meikaprince/Desktop/purrrfectPals/purrrfectpals/node_modules/got/source/merge.js"],"names":["require","URL","is","knownHookEvents","merge","target","sources","source","Object","entries","key","sourceValue","undefined","targetValue","urlInstance","string","plainObject","array","mergeOptions","map","merged","hooks","hook","concat","mergeInstances","instances","methods","handlers","instance","defaults","handler","size","length","options","next","iteration","iterate","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst {URL} = require('url');\nconst is = require('@sindresorhus/is');\nconst knownHookEvents = require('./known-hook-events');\n\nconst merge = (target, ...sources) => {\n\tfor (const source of sources) {\n\t\tfor (const [key, sourceValue] of Object.entries(source)) {\n\t\t\tif (is.undefined(sourceValue)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst targetValue = target[key];\n\t\t\tif (is.urlInstance(targetValue) && (is.urlInstance(sourceValue) || is.string(sourceValue))) {\n\t\t\t\ttarget[key] = new URL(sourceValue, targetValue);\n\t\t\t} else if (is.plainObject(sourceValue)) {\n\t\t\t\tif (is.plainObject(targetValue)) {\n\t\t\t\t\ttarget[key] = merge({}, targetValue, sourceValue);\n\t\t\t\t} else {\n\t\t\t\t\ttarget[key] = merge({}, sourceValue);\n\t\t\t\t}\n\t\t\t} else if (is.array(sourceValue)) {\n\t\t\t\ttarget[key] = merge([], sourceValue);\n\t\t\t} else {\n\t\t\t\ttarget[key] = sourceValue;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn target;\n};\n\nconst mergeOptions = (...sources) => {\n\tsources = sources.map(source => source || {});\n\tconst merged = merge({}, ...sources);\n\n\tconst hooks = {};\n\tfor (const hook of knownHookEvents) {\n\t\thooks[hook] = [];\n\t}\n\n\tfor (const source of sources) {\n\t\tif (source.hooks) {\n\t\t\tfor (const hook of knownHookEvents) {\n\t\t\t\thooks[hook] = hooks[hook].concat(source.hooks[hook]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmerged.hooks = hooks;\n\n\treturn merged;\n};\n\nconst mergeInstances = (instances, methods) => {\n\tconst handlers = instances.map(instance => instance.defaults.handler);\n\tconst size = instances.length - 1;\n\n\treturn {\n\t\tmethods,\n\t\toptions: mergeOptions(...instances.map(instance => instance.defaults.options)),\n\t\thandler: (options, next) => {\n\t\t\tlet iteration = -1;\n\t\t\tconst iterate = options => handlers[++iteration](options, iteration === size ? next : iterate);\n\n\t\t\treturn iterate(options);\n\t\t}\n\t};\n};\n\nmodule.exports = merge;\nmodule.exports.options = mergeOptions;\nmodule.exports.instances = mergeInstances;\n"]},"metadata":{},"sourceType":"script"}