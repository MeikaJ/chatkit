{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/meikaprince/Desktop/purrrfectPals/purrrfectpals/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst EventEmitter = require('events');\n\nconst getStream = require('get-stream');\n\nconst is = require('@sindresorhus/is');\n\nconst PCancelable = require('p-cancelable');\n\nconst requestAsEventEmitter = require('./request-as-event-emitter');\n\nconst _require = require('./errors'),\n      HTTPError = _require.HTTPError,\n      ParseError = _require.ParseError,\n      ReadError = _require.ReadError;\n\nconst _require2 = require('./merge'),\n      mergeOptions = _require2.options;\n\nconst _require3 = require('./normalize-arguments'),\n      reNormalize = _require3.reNormalize;\n\nconst asPromise = options => {\n  const proxy = new EventEmitter();\n  const promise = new PCancelable((resolve, reject, onCancel) => {\n    const emitter = requestAsEventEmitter(options);\n    onCancel(emitter.abort);\n    emitter.on('response', async response => {\n      proxy.emit('response', response);\n      const stream = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);\n      let data;\n\n      try {\n        data = await stream;\n      } catch (error) {\n        reject(new ReadError(error, options));\n        return;\n      }\n\n      const limitStatusCode = options.followRedirect ? 299 : 399;\n      response.body = data;\n\n      try {\n        for (const _ref of Object.entries(options.hooks.afterResponse)) {\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          const index = _ref2[0];\n          const hook = _ref2[1];\n          // eslint-disable-next-line no-await-in-loop\n          response = await hook(response, updatedOptions => {\n            updatedOptions = reNormalize(mergeOptions(options, { ...updatedOptions,\n              retry: 0,\n              throwHttpErrors: false\n            })); // Remove any further hooks for that request, because we we'll call them anyway.\n            // The loop continues. We don't want duplicates (asPromise recursion).\n\n            updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n            return asPromise(updatedOptions);\n          });\n        }\n      } catch (error) {\n        reject(error);\n        return;\n      }\n\n      const _response = response,\n            statusCode = _response.statusCode;\n\n      if (options.json && response.body) {\n        try {\n          response.body = JSON.parse(response.body);\n        } catch (error) {\n          if (statusCode >= 200 && statusCode < 300) {\n            const parseError = new ParseError(error, statusCode, options, data);\n            Object.defineProperty(parseError, 'response', {\n              value: response\n            });\n            reject(parseError);\n            return;\n          }\n        }\n      }\n\n      if (statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {\n        const error = new HTTPError(response, options);\n        Object.defineProperty(error, 'response', {\n          value: response\n        });\n\n        if (emitter.retry(error) === false) {\n          if (options.throwHttpErrors) {\n            reject(error);\n            return;\n          }\n\n          resolve(response);\n        }\n\n        return;\n      }\n\n      resolve(response);\n    });\n    emitter.once('error', reject);\n    ['request', 'redirect', 'uploadProgress', 'downloadProgress'].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));\n  });\n\n  promise.on = (name, fn) => {\n    proxy.on(name, fn);\n    return promise;\n  };\n\n  return promise;\n};\n\nmodule.exports = asPromise;","map":{"version":3,"sources":["/Users/meikaprince/Desktop/purrrfectPals/purrrfectpals/node_modules/got/source/as-promise.js"],"names":["EventEmitter","require","getStream","is","PCancelable","requestAsEventEmitter","HTTPError","ParseError","ReadError","mergeOptions","options","reNormalize","asPromise","proxy","promise","resolve","reject","onCancel","emitter","abort","on","response","emit","stream","null","encoding","buffer","data","error","limitStatusCode","followRedirect","body","Object","entries","hooks","afterResponse","index","hook","updatedOptions","retry","throwHttpErrors","slice","statusCode","json","JSON","parse","parseError","defineProperty","value","once","forEach","event","args","name","fn","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst EventEmitter = require('events');\nconst getStream = require('get-stream');\nconst is = require('@sindresorhus/is');\nconst PCancelable = require('p-cancelable');\nconst requestAsEventEmitter = require('./request-as-event-emitter');\nconst {HTTPError, ParseError, ReadError} = require('./errors');\nconst {options: mergeOptions} = require('./merge');\nconst {reNormalize} = require('./normalize-arguments');\n\nconst asPromise = options => {\n\tconst proxy = new EventEmitter();\n\n\tconst promise = new PCancelable((resolve, reject, onCancel) => {\n\t\tconst emitter = requestAsEventEmitter(options);\n\n\t\tonCancel(emitter.abort);\n\n\t\temitter.on('response', async response => {\n\t\t\tproxy.emit('response', response);\n\n\t\t\tconst stream = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);\n\n\t\t\tlet data;\n\t\t\ttry {\n\t\t\t\tdata = await stream;\n\t\t\t} catch (error) {\n\t\t\t\treject(new ReadError(error, options));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst limitStatusCode = options.followRedirect ? 299 : 399;\n\n\t\t\tresponse.body = data;\n\n\t\t\ttry {\n\t\t\t\tfor (const [index, hook] of Object.entries(options.hooks.afterResponse)) {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tresponse = await hook(response, updatedOptions => {\n\t\t\t\t\t\tupdatedOptions = reNormalize(mergeOptions(options, {\n\t\t\t\t\t\t\t...updatedOptions,\n\t\t\t\t\t\t\tretry: 0,\n\t\t\t\t\t\t\tthrowHttpErrors: false\n\t\t\t\t\t\t}));\n\n\t\t\t\t\t\t// Remove any further hooks for that request, because we we'll call them anyway.\n\t\t\t\t\t\t// The loop continues. We don't want duplicates (asPromise recursion).\n\t\t\t\t\t\tupdatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n\n\t\t\t\t\t\treturn asPromise(updatedOptions);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {statusCode} = response;\n\n\t\t\tif (options.json && response.body) {\n\t\t\t\ttry {\n\t\t\t\t\tresponse.body = JSON.parse(response.body);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (statusCode >= 200 && statusCode < 300) {\n\t\t\t\t\t\tconst parseError = new ParseError(error, statusCode, options, data);\n\t\t\t\t\t\tObject.defineProperty(parseError, 'response', {value: response});\n\t\t\t\t\t\treject(parseError);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {\n\t\t\t\tconst error = new HTTPError(response, options);\n\t\t\t\tObject.defineProperty(error, 'response', {value: response});\n\t\t\t\tif (emitter.retry(error) === false) {\n\t\t\t\t\tif (options.throwHttpErrors) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(response);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve(response);\n\t\t});\n\n\t\temitter.once('error', reject);\n\t\t[\n\t\t\t'request',\n\t\t\t'redirect',\n\t\t\t'uploadProgress',\n\t\t\t'downloadProgress'\n\t\t].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));\n\t});\n\n\tpromise.on = (name, fn) => {\n\t\tproxy.on(name, fn);\n\t\treturn promise;\n\t};\n\n\treturn promise;\n};\n\nmodule.exports = asPromise;\n"]},"metadata":{},"sourceType":"script"}